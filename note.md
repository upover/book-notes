### Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
### git
* 使用
源分支：目的分支
* pull
用于取回远程主机某个分支的更新与本地的指定分支合并。
pull <远程主机名> <远程分支名>：<本地分支名>
git pull origin master:my_test
上面的命令是将origin厂库的master分支拉取并合并到本地的my_test分支上。
如果省略本地分支，则将自动合并到当前所在分支上。如下：
git pull origin master
* push
用于将本地分支的更新，推送到远程主机
push <远程主机名> <本地分支名>：<远程分支名>
如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。
git push origin master
origin是一个远程厂库地址,上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 
### Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
* redis插入性能:每秒10万
* Redis事务:使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
* Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
* sds简单动态字符串特点：
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
### 数据库
* 范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
* 删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高，删除数据不删除表结构 
drop table table1删除表及结构
* 何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
* 数据库引擎：基于表，而不是数据库。
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
* 事务：把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
* 死锁：两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
*3种多个事务同时操作时，数据库误读现象
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

* 数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
* 锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
* 行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
* 数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
* 分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
* 约束
添加约束时，会先检测已经存在的数据是否满足约束条件，否则不能添加约束
UNIQUE:通过唯一性索引来强制实体完整性，允许NULL值，每列只允许1个；每张表可以定义多个，而Primary Key约束只能定义一个；FOREIGN KEY约束可以引用UNIQUE约束。
* 排序(mysql不支持top关键字，用limit)
order by可以包含未显示在选择列表中的项，当指定distinct或包含group by，或select包含union运算符时不可以
* count
count(*)返回所有列数，count(col)返回某一列非空列数
* 连接查询
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

### 网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
### 计算机、操作系统
* 寄存器：  
通用寄存器（保存变量和临时结果）、程序计数器、堆栈指针、程序状态字
* 程序： 内核态（使用所有的指令集，操作系统运行在内核态）、用户态（应用程序,使用陷阱而不是指令来执行系统调用切换成内核态，调用操作系统）
不同存储介质，随机访问时间不同。寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
* 进程：  
正在执行的一个程序，有地址空间，uid（创建该线程的用户标识，子进程和父进程拥有相同的uid），两个概念是资源分配和执行，进程是程序的一个实例，是资源分配的最小单位
* 线程：  
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有独立的程序计数器、寄存器、堆栈、状态等，共享进程的地址空间。
* 进程间同步： 将信号量放在共享内存中，并用TSL或XCHG指令来保护，可以避免竞争，解决访问的互斥问题。
* 管程：编程语言概念，编译器必须识别管程并用某种方式对其互斥做出安排。一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制，java（同步方法，没有内嵌的条件变量，提供了两个过程wait和notify）支持管程
屏障
进程组同步
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，信号量（计数）、互斥量（两种状态），条件变量、消息量，事件
* 临界区：访问共享内存的程序片段
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
* 内存管理
虚拟内存是内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
* 虚拟内存技术：MMU（存储管理单元）查找虚拟页面列表到实际页框的映射（页表项，对应每一个页面），将虚拟地址转换为实际物理地址，如果存在缺页时，陷入缺页中断，交换后，更新虚拟页面列表。
分页加速技术：1.加入TLB（转换检测缓冲区，硬件设备），在原有的页表上，引入一个小的常用的快表。  
2.多级页表  
3.倒排页表，64位系统，页表较多，对应的页表项所需空间较大，优点是节省空间，缺点是需要搜索倒排页表。解决办法，一是加入TLB,二是加入散列表，用虚拟地址来散列。
* 页面置换算法：
最近未使用页面置换算法（NRU），先进先出页面置换算法（FIFO），第二次机会页面置换算法（把页面根据时间建成链表，根据R位判断是否插入链表尾部），时钟页面置换算法（把链表换成了时钟表示法，每次往前移动一个位置），最近最少使用页面置换算法（LRU）,工作集页面置换算法
* 全局置换或是局部置换：根据页面属于某个进程还是所有进程。
* 页面大小 内部碎片，正文、数据、堆栈等的最后一个页面有空的部分
* 共享库： 动态链接，大部分程序都会调用的代码，需要编译为位置无关代码。
* 内存映射文件： 进程发起系统调用，将一个文件映射到其虚拟地址空间的一部分，可以共享内存实现进程间通信。
分块、分页、分段

* 页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
* 段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的，优点：简化对数据长度经常变动的数据结构的管理，简化把单独编译好的过程链接起来的过程。

* I/O设备
块设备：块可寻址和独立读写；字符设备：以字符为单位发送或接收一个字符流。
设备控制器或适配器控制设备，通过寄存器与CPU进行通信，I/O端口或者内存映射I/O,DMA直接存储器存取
* 硬件中断
在总线信号线上置起信号而产生中断，由主板上的中断控制器芯片检测到，中断控制器在地址线上放置数字表明是哪个设备需要关注，并置一个中断CPU的信号。
* 4种死锁处理策略：忽略该问题（鸵鸟算法），检测死锁并恢复，死锁预防（破坏死锁的4个条件，使用假脱机技术（互斥）；进程开始必须一次性请求所需的所有资源（占有和等待）；抢占资源；对资源顺序编号，依次申请资源（环路等待），死锁避免（系统判断是否认可这个申请，银行家算法，实际不太可能实现）
* 活锁，线程一直在运行状态，但做无用功（忙等待，空转）
* 死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。同时满足4个条件（互斥，占有和等待，不可抢占，循环等待）
* 饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。

* 库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
* 业务设计原则
1. 防重设计：防重Key,防重表
2. 幂等设计：
3. 状态与状态机  
4. 后台系统操作可反馈
5. 后台系统审批化
6. 文档和注释
7. 备份
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台  
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
### 计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
Maven
基于项目对象模型（project object model,pom）的概念，用来管理项目的依赖、编译和文档等信息。项目依赖的jar包集中放在用户的仓库目录下。
Redis
redis获取一个hash的长度、Redis数据结构，跳跃表，原子操作
为什么redis生成id
redis插入性能
每秒10万
Redis事务
使用事务队列，watch命令，key-watches字典，保存键和监视键的客户端列表，修改后，客户端的redis-dirty-cas标志打开，拒绝事务执行，返回空
Redsi不支持回滚机制，解释：这种复杂的功能与redis追求简单高效的设计主旨不符，事务的执行时错误通常都是编译错误，只会出现在开发环境中，很少会在实际的生产环境中出现。
sds简单动态字符串
常数复杂度获取字符串长度
杜绝缓冲区溢出；
减少修改字符串长度是所需的内存重分配次数
二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能



算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能

二进制安全
数据库
范式：1nf：列的原子性2nf:必须有主键，非主键列必须完全依赖主键3nf：不能存在传递依赖,属性不依赖于其他非主属性，bcnf:
删除表中数据：
用法 delete from table1;delete from table1 where …;truncate table table1;
Delete可以回滚，truncate不可以，truncate效率高 
drop table table1删除表及结构
何时建索引	
不适合：表记录太少；经常修改的表；数据重复且分布平均的表字段。
数据库引擎
基于表，而不是数据库
InnoDB(mysql5.5.8开始的默认存储引擎)：支持事务，行锁设计，支持多版本并发控制（mvcc，通过undo log实现）,提供一致性非锁定读，支持外键，面向在线事务处理应用（oltp）
MyISAM:不支持事务，表锁设计，支持全文索引，面向在线分析处理应用（olap）
数据库索引失效，表正在用，索引不能删除，怎么处理
事务
把数据库从一种一致性状态转换到另一种一致性状态，确保一系列操作，要么全部执行，要么回滚。
两个或以上事务在执行过程中，因争夺锁资源而互相等待的现象。
Innodb采用等待图的方式解决死锁，回滚
Acid特征，原子性（借助redo log重做日志），一致性（undo log来保证），隔离性，持久性（数据库中事务的更新是不会丢失的,借助redo log）
redo log重做日志缓冲，重做日志文件，undo log存储在段中，存储undo log时也要存储redo log(也需要持久性的保护);
脏读：一个事务读取了另一个事务未提交的数据；
不可重复读：一个事务的多次读取查询中，由于另一个事务的修改，读取的数据不一致，重点在修改，需要锁住满足条件的行；
幻读：一个事务的处理表中的全部数据行，第二个事务插入了新的数据，第一个事务就会发现有未处理的行，重点在insert，添加了新的行，需要锁表；

数据库4种隔离级别：
串行化，避免脏读，不可重复读，幻读；
可重复读（MySQL默认）：避免脏读、不可重复读 底层原理（使用nextlocking范围锁）
读取提交：避免脏读
读取未提交：
锁模式
共享锁：并发读取操作的锁，任何事务在获取排它锁前，需要释放所有共享锁
排它锁：
更新锁：防止通常形式的死锁，两个事务获取共享锁时试图更新数据，都需要等待对方释放共享锁，自己转换为排它锁，导致死锁。只有一个事务可以获得更新锁，事务需要更改资源时，更新锁转换为排它锁，否则转换为共享锁。
行锁的3种算法
Record lock单个行记录上的锁
Gap lock,间隙锁：锁定一个范围，不包含记录本身
Next-key lock 锁定一个范围，包含记录本身
数据库优化和分库分表 主要介绍2、3
 1、数据库运维方面的优化：启用数据库缓存。对于一些比较常用的查询可以采用数据库缓存的机制，部署的时候需要注意设置好缓存依赖项，防止“过期”数据的产生。
2、数据库索引方面的优化：比如常用的字段建立索引，联合查询考虑联合索引，注意索引失效的问题。（PS：如果你有基础，可以敞开谈谈聚集索引和非聚集索引的使用场景和区别）
3、数据库查询方面的优化：避免select * 、like模糊查询，尽量不用in和not in 这种耗性能的用法等等
4、数据库算法方面的优化：尽量避免大事务操作、减少循环算法，对于大数据量的操作，避免使用游标的用法等等
分库分表
垂直划分：按照功能业务层面、时间日期垂直分表
水平划分：根据用户id采用哈希算法划分
备份和恢复
按照备份的方法不同分为热备份（运行时），冷备份（离线），温备份
按照备份后文件的内容，分为逻辑备份（备份出的文件内容是可读的，文本文件，由sql语句或实际数据组成，时间长），裸文件备份（复制数据库的物理文件）
按照备份数据库的内容来分，分为完全备份，增量备份，日志备份
内连接（返回等值连接）、外连接（左/右，返回左/右边表的所有行）

网络
http状态码301,302
2xx成功
3xx表示重定向，301永久转移位置，302临时转移位置，304未修改。
4xx客户端出错（400错误的请求，403，禁止执行访问，404）
5xx服务器端出错（501，没有相应的执行动作，502，网关或代理的服务器，从上游服务器接收到无效响应，504上游服务器超时）
DHCP如何实现分配ip的，数据包格式和原理 客户服务器方式
动态主机配置协议：Dhcp客户端监听68端口，udp报文，广播发送发现报文，只有dhcp服务器才进行回答，监听67端口，发送提供报文，客户选择一个，向其发送dhcp请求报文，被选择的服务器发送确认报文。
三次握手，四次握手
C->SYN,S->ACK,C->ACK,三次握手防止失效的连接请求发送到S（服务器）；
C->FIN=1，S->ACK,S->FIN-1，C->ACK(C进入time-wait阶段，2个最长报文段寿命),为了保证C的最后一个ACK报文段发送到S,防止已失效的连接请求出现在本连接中。
避免表单重复提交
1.	数据库中，对账号、名称信息添加唯一性约束
2.	使用Js隐藏提交按钮
3.	PRG模式，提交后，使用客户端重定向到提交成功页面
4.	在表单的隐藏域中设置session标识号，提交后服务端清除session。
http请求方式，post和put区别，options
post和put都用来创建或者更新资源，post用于每次都是新的资源，put用于幂等操作。
请求报文：方法 url 协议版本
options: 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
get:请求读取url所标志的信息，
post:给服务器添加信息
put:在指明的url下存储一个文档
响应报文：第一行是状态行（包括http的版本，状态码，解释状态码的简单短语）
数据链路层，最大传送单元mtu
6字节的mac地址，网桥工作在数据链路层，扩展以太网，路由器在网络层，网关在网络层以上
Ip地址：网络号+主机号
网络号全0表示本网络，127表示软件环回测试，主机号全0表示网络地址，全1表示该网络上的所有主机。
局域网内，Arp地址解析协议，从Ip地址-硬件地址
每台主机都有arp高速缓存，里面有本局域网上各主机和路由器的ip地址到硬件地址的映射，a主机广播发送arp请求，b主机单播响应，arp解决同一个局域网的ip和主机映射问题。
不在同一个局域网上需要通过路由器分组转发，路由器连接不同网络号，存有路由表，目的网络号-下一跳地址
Vpn:专用网络 本地地址、全球地址 远程接入
http长连接，推送
http1.0和1.1区别
http1.1：默认支持长连接，多次请求只建立一次tcp连接；
支持只发送header信息，节约带宽；
host请求头表示要访问哪个web站点，实现在一台服务器上使用不同的主机名创
建多个虚拟web站点；
支持断点续传；
http2.0:多路复用，数据压缩（header数据），服务器推送
推送：
ajax轮询：定时发送请求；
长轮询：服务器保持连接，有数据更新时再返回数据
Web socket：html5支持的协议，基于http协议升级建立全双工通信的tcp连接
https:基于tsl/ssl的http协议，浏览器和服务器多了一次握手过程，利用非对称加密验证双方的密码信息，之后用密码对称加密数据
tcp、udp区别
UDp：支持一对一，一对多，多对一，多对多；无连接；面向报文，过长时ip数据报可能会分片，没有拥塞控制，实时性高
udp首部8个字节，tcp最小20字节
tcp：支持一对一，可靠交付，全双工通信，tcp连接的两端有接收和发送缓冲区，面向字节流
tcp连接的端点：套接字（ip：端口号）
ip数据报首部最小20字节，包括版本，首部长度，总长度，片偏移，源、目的地址等
tcp可靠传输的实现， 
流量控制，滑动窗口协议，零窗口死锁问题，tcp为每一个连接设有一个持续计数器，设置时间到时发送一个1字节数据的探测报文段。
网络拥塞，需求的资源大于可用资源，拥塞控制算法：慢开始，拥塞避免，快重传和快恢复
Dns域名解析系统，向本地域名服务器递归查询，向顶级域名服务器迭代查询。
token （调用json web token包） 
一个Token就是一些信息的集合；
在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 
服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；
基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；
因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；
负载均衡策略
计算机、操作系统
寄存器、缓存、主存（依靠电脉冲寻址），磁盘（机械装置，依靠机械指针转动寻址）
管程：一个由过程，变量及数据结构组成的一个集合，组成一个特殊的模块或软件包。任一时刻管程中只有一个活跃进程，保证互斥。引入条件变量实现阻塞。实现由编译器控制
屏障
进程是程序的一个实例，是资源分配的最小单位
线程是进程的一个实体，是cpu调度的基本单位，共享进程的资源，有自己的寄存器，堆栈，程序计数器；
进程间如何通信（IPC）
管道
命名管道
套接字
共享内存
消息队列
线程同步机制
临界区，互斥量，消息量，事件
活锁，线程一直在运行状态，但做无用功
死锁，两个或多个进程被无限期的阻塞、相互等待的一种状态。4个条件（互斥，不可抢占，占有和等待，循环等待）
饥饿：资源分配，某个线程一直得不到资源，可用先来先服务的分配策略避免。
死锁处理策略：检测和恢复，死锁预防（破坏死锁的4个条件，进程必须一次性请求所需的所有资源，申请新资源时，需要释放已有资源，对资源顺序编号，依次申请资源），死锁避免（系统判断是否认可这个申请，银行家算法）
进程调度策略
先来先服务，短作业优先调度，优先权调度，基于时间片的轮转调度
windows内存管理
分块、分页、分段
页是信息的物理单位，实现离散分配方式，提高内存的利用率，用户程序分成固定大小的页，内存空间分成若干物理块，页和块大小相等。
段是信息的逻辑单位，如程序段，数据段等，将用户程序地址空间分成若干大小不等的段，地址空间是二维的
虚拟内存
内存管理的一项技术，相对于物理内存而言的，每个程序拥有自己的连续可用的地址空间，允许程序员编写和运行比实际系统拥有的内存大得多的程序。
每个空间被分割成多个块，每一块称作页或页面，每一页有连续的地址范围，这些页被映射到物理内存，但不是所有的页都必须在内存中才能运行程序，当程序引用到在物理内存中的地址空间时，由硬件立刻执行必要的映射，当程序引用到不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存重新执行失败的指令。
虚拟地址被内存管理单元（mmu）映射为物理内存地址
好处:扩大地址空间，进程间内存保护，公平分配内存，进程通信时可采用虚存共享的方式
缺点：虚存管理额外数据结构消耗内存，地址转换增加指令执行时间，页面换入和换出需要磁盘io
库函数和系统调用的不同
库函数是语言或应用程序的一部分，运行在用户空间，属于过程调用，开销小；系统调用是内核提供给应用程序的接口，属于操作系统的一部分，需要在用户态和内核态切换，开销大。
文件是怎么在磁盘上存储的？
分文件系统，比如linux的ext2系统，u盘的FAT、ntfs等，ext2属于索引式文件系统，根据inode找到数据块block，fat下一个block处在上一个block中。磁盘最小的物理存储单位是扇区。
怎么用减法实现除法，怎么优化？
mybatis和hibernate的区别
相同：持久化框架，通过session，整合jdbc，和数据库交互。
mybatis半自动，提供基本的字段映射，对象和数据间的实际关系需要自己手动写sql语句实现，和数据库耦合较多，sql语句的优化方便很多
hibernate 全自动，不用手动写sql，强大的映射结构和hql语言，降低了对象和数据库的耦合性，数据库无关性强，提供完整的日志系统；
设计模式
常用的设计模式，jdk中有哪些应用
策略模式，一系列strategy类封装一系列算法，在context类中传入选择的算法，减少了算法类和使用算法类之间的耦合
单一职责原则、开放封闭原则依赖倒转原则（针对接口不针对实现编程）、里氏代换原则（子类型必须能替换掉父类型）
迪米特法则，两个类不必彼此直接通信，不应当发生直接的相互作用。强调类之间的松耦合
装饰模式，把要装饰的功能放在单独的类中，包装它所装饰的对象，动态给对象添加职责。
代理模式，为其他对象提供一种代理，控制对这个对象的访问。     
两者的区别，装饰关注在一个对象上动态的增加方法，可以多层嵌套，代理关注对对象的访问          
简单工厂模式：实现了生成产品类的代码跟客户端代码分离             
工厂方法模式：运用了对修改封闭，对扩展开放，增加一个工厂类，工厂方法模式中我们把生成产品类的时间延迟，就是通过对应的工厂类来生成对应的产品类      
原型模式：用原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象 对引用对象的浅复制，和深复制
模板方法模式：定义操作的骨架，将具体步骤延迟到子类中，提供了代码复用平台                                                                                                                                                                                                                                                                                                                                                                                                                                            
内存模型
程序计数器：较小的内存，当前线程执行字节码的指示器，每条线程私有，唯一不抛oom的区域
虚拟机栈：
保存方法执行的内存模型，每个方法的栈帧（局部变量表，操作数栈，方法出口等），线程请求的栈深度超过虚拟机允许的深度时，抛出stackoverflow异常，虚拟机栈动态扩展时无法申请足够的内存，抛出oom异常
本地方法栈：
执行native方法的栈，抛出Stack Overflow和oom异常
堆：存放对象实例，没有内存完成实例分配，并且无法再扩展时，抛oom异常
方法区：
存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码，回收目标主要是常量池的回收和类型的卸载，抛出oom异常，运行时常量池：具有动态性，常量不一定在编译期产生，string类的intern方法
直接内存：
不是虚拟机内存区域，jdk1.4引入的nio类，引入基于通道和缓冲区的方式，使用native函数库直接操作堆外内存，避免在java堆和native堆来回复制数据，受到本机总内存和处理器寻址空间的限制，程序直接或间接使用nio时会出现直接内存的oom异常。
对象创建：
指针碰撞、空闲列表，取决于内存是否规整，与垃圾收集器有关，
并发时内存分配问题，
一是对分配空间操作进行同步锁定，采用cas配上失败重试的方式保证原子性，二是按照线程划分在不同的空间中进行（TLAB），内存初始化为零值，对对象头进行设置，属于哪个类，对象的哈希码，分代年龄等，虚拟机运行状态的不同，是否启用偏向锁等。最后，执行< inti >方法，初始化对象
对象内存布局：
对象头（自身运行时数据、类型指针，数组对象在对象头中记录数组长度的数据，对齐填充）
对象访问：
栈帧中的引用到堆中的实例的访问，句柄池（指针分别指向对象实例和类型数据）和直接指针（指针指向类型数据）
判断对象是否存活
引用计数算法很难解决对象循环引用问题。
可达性分析算法，从gc roots对象开始搜索引用路径，判断对象的引用链是否可达。可作为gc roots的对象(虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类的静态属性引用的对象，常量引用的对象)
四种引用强度
强引用>软引用>弱引用>虚引用
强：创建一个对象并把这个对象赋给一个引用变量,Object aref = new object; 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。中断引用时，将aref=null;
软：描述还有用但并非必须的对象，如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，SoftReference aSoftRef = new SoftReference(aref) SoftReference的特点是它的一个实例保存对一个Java对象的软引用， 该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。aSoftRerenct.get()可以获得aref对象的强引用，回收后，返回null,
构造时带queue,ReferenceQueue queue = new ReferenceQueue();SoftReference aSoftRef = new SoftReference(aref,queue);可用queue的poll方法获取前一个软引用
弱：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
WeakReference<People>reference=new WeakReference<People>(people);
虚：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，虚引用必须和引用队列关联使用，为的是对象被回收时收到一个通知。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动
WeakHaspMap,是映射的生命周期和键的生命周期联系在一起。WeakHashMap 有一个名为 expungeStaleEntries() 的私有方法，和引用队列配合使用，删除关联的无效映射。
对象死亡过程
至少经历两次标记过程，第一次不可达时，标记和筛选，筛选条件是是否有必要执行finalize()方法（只执行一次），没有则标记为即将回收，有则放入F-QUEUE队列中执行，在finalize()方法中有可能逃脱，第二次时标记时回收
方法区的回收：废弃常量和无用的类（堆中没有该类的实例，classloader已被回收，对应的class对象没有在任何地方被调用）。
垃圾收集算法
标记清除 复制 标记整理
分代收集算法：新生代（复制）老年代（标记清除或整理）
垃圾收集器
新生代：serial,单线程收集;parnew，多线程并行收集，parallel scavenge,目标是达到一个可控制的吞吐量（cpu运行用户代码时间和总消耗时间的比值），自适应调节策略
老年代：serial old,parallel old,concurrent mark sweep收集器,以获取最短回收停顿时间为目标，
Cms收集器过程 初始标记（与gc roots直接连的）并发标记（可达性分析）重新标记（纠错）并发清除 缺点是对CPU资源敏感，无法处理浮动垃圾，回收结束后产生内存碎片。
G1收集器 特点 并行与并发，分代收集，空间整合，可预测的停顿
内存分配和回收策略
大多情况下，对象在新生代eden区分配，eden没有足够空间时，发起一次minor gc,
大对象（需大量连续内存的对象，如很长的字符串或数组，提供参数设置阈值）、长期存活的对象（对象年龄计数器）直接进入老年代
在minor gc 之前，若老年代最大可用连续区间是否大于新生代所有对象总空间，若不成立，如果允许担保失败则检查老年代最大可用的连续空间是否大于历次晋升到老年代的平均大小，如果小于或者不允许担保失败冒险，则进行一次full gc
常用jvm参数
-Xmx3550m,设置堆最大可用内存
-Xms堆初始内存大小
-Xmn新生代大小
-Xss每个进程的堆栈大小
为什么会有内核态，保护模式你知道吗?
当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。内核态: CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. 
当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态），只能受限的访问内存, 且不允许访问外围设备
保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据

如果你的项目出现了内存泄露，怎么监控这个问题呢
在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连，仍然被引用；其次，这些对象是无用的，即程序以后不会再使用这些对象。典型的，如静态集合，缓存
确认一个对象无用后，将其所有引用显示的置位null，
监测：内存检测工具JRockit，比如长时间下哪些类数目在增长

OutofMemoryError:堆内存不足，存在内存泄漏

Jdk源码
1.8的新特性
接口中默认方法；lambda表达式和函数式接口；hashmap链表长度大于8时改用红黑树。
红黑树效率提高多少，logN
String,stringbuffer,stringbuilder
String是不可变对象(final)，底层是char数组，stringbuffer是线程安全的（synchronized），stringbuilder是非线程安全的。
ArrayList:数组
LinkedList：链表节点
反射
动态代理实现：在运行时创建一个实现一组给定接口的新类。
具体有如下四步骤： 
1. 通过实现 InvocationHandler 接口创建自己的调用处理器； 
2. 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类的类对象； 
3. 通过反射机制获得动态代理类对象的构造函数对象，其唯一参数类型是调用处理器接口类型； 
4. 通过构造函数对象创建动态代理类实例，构造时调用处理器对象作为参数被传入
通过类proxy的newInstance静态方法以及InvocationHandler回调接口实现,只能对接口进行代理，有固定的父类proxy。在代理类中调用方法时，都会先调用InvocationHandler中的invoke方法
CGlib如何实现
通过字节码扩充父类（被代理类）的Class创建代理对象，
CGLIB和Java动态代理的区别
Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为所有生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类；
Java动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效.

Object类中的方法
equals()方法
hashCode()方法，其值为对象的存储地址
clone()是protected的，toString,wait,notify,notifyall是native方法,在底层虚拟机中实现。
toString()方法，object。打印类名+散列码
通常是类名，随后是一对方括号括起来的域值，数组要用静态方法Arrays.toString()
Finalize()，回收对象时调用
Wait(),notify(),notifyall()方法
hashmap，hashtable,ConcurrentHashMap(JDK1.8)分布式锁
hashmap 并发问题
put操作，扩容重哈希时，可能形成环形链表，导致get无限循环；
同时put时，产生哈希碰撞，出现覆盖丢失的情况。
indexfor的计算方法是index=h&(length-1),length一般是2的整数次幂，原因：后面保持不变（length-1的低位部分），扩容时减少老数据的位置调换；全是1，索引index更加均匀，散列冲突的几率也更小。hash(object key)中高位和低位异或，利用高位参与运算，减少哈希碰撞
hashtable全部加锁
concurrenthashmap在jdk1.5时使用分段锁（默认16个）jdk1.8时改为cas和synchronize，只在每个链表头结点或者红黑树的根节点加锁
解决hash冲突的方法
开放定址法：线性探测再散列，二次探测再散列，伪随机探测再散列
再哈希法：构造多个哈希函数
链地址法：将哈希值相同的元素构成一个单链表，适合经常进行插入和删除的情况
建立公共溢出区
nio和bio，bio底层怎么实现的呢，举例子
bio同步阻塞，往往是一个连接对应一个线程，面向流，可通过线程池机制改善，适用于连接数目比较小且固定的架构
nio同步非阻塞，使用单线程或少量多线程，连接共用一个线程，连接注册到多路复用器上，一个请求一个线程，适用于连接数目多且连接比较短的架构，jdk4开始支持，
selectors监视和管理多个通道（channel），面向缓冲区(buffer)，非阻塞，
channel主要有：
filechannel(对应文件)，datagramchannel(对应udp),socketchannel,serversocketchannel(对应tcp)
Selection key = channel.register(selector,SelectionKey.OP_READ)注册到选择器
select()方法返回准备就绪的通道个数，selectedKeys()方法返回已选择键集，selectionkey.isAcceptable()方法判断感兴趣的事件，selectionkey.channel()对通道处理
aio异步非阻塞，是一个有效请求（需要读写）一个线程，适用于连接数目多且连接比较长的架构。Jdk7开始支持
I/O多路复用：一个进程可以监控多个描述符
，select poll epoll区别
Select:是轮询，有数量限制（fd_setsize决定），操作限制，每次都要轮询一遍,效率低，
Poll:数量几乎无限制（对应的fd列表由数组保存），操作有限制，fd数组需要在内核态和用户态来回复制，水平触发，报告fd后，没有处理下次会再次报告。
Epoll:数量几乎无限制，操作无限制，基于内核提供的callback模式

jdbc中的prepareStatement预编译，可以绑定变量重复使用，对批量处理可以提高效率，防止sql注入的危险。
Statement为每一条执行语句生成执行计划，执行一次性存取时，用statement对象处理，preparementStatement的开销比statement大。
抽象类和接口的区别
1.一个类可以实现多个接口，只能继承一个类
2.抽象类可以包含具体的方法，接口的方法都是抽象的，1.8提供默认方法
3.抽象类可以声明和使用字段，接口不能，只能创建静态final常量
4.接口的方法都是public的
5.抽象类可以定义构造函数
使用场景，既需要规范统一的接口，又需要实例变量或缺省方法的情况下，使用抽象类
接口：方法自动public，所有域自动为public static final，1.8中接口提供静态方法，接口中也可以有默认实现，用default
解决默认方法冲突：超类优先，接口发生冲突时必须覆盖这个方法。
Lambda表达式
内部类：访问外围类的所有域，对同一个包中的其他类隐藏，匿名内部类定义回调函数
只有内部类可以是private，
局部内部类：声明在局部方法中，不能用修饰符修饰，只可以引用final的局部变量
匿名内部类：实现某个接口的类
静态内部类：不需要访问外围类对象
处理错误的机制：抛异常，断言，日志
泛型:不能构造泛型数组，不能实例化类型变量，不能用基本类型实例化类型参数，泛型类的静态上下文中类型变量无效，
线程池，状态，shutdown和stop的区别 线程池里面的线程出现了故障怎么办
创建线程的方法：继承Thread类，实现Runnable接口，使用Callable和FutureTask
关闭线程的方法：
1.设置退出标志，使线程正常退出；
2.使用Interrupt设置中断可用来请求终止线程，线程处于阻塞状态时，抛出interruptexception异常，并把中断标志设置为false,捕获该异常退出；处于非阻塞状态时，在被关闭的线程中判断isInterrupted()
3.使用stop方法终止线程，释放子线程持有的所有锁。线程不安全。
Reentrantlock和synchronized之间选择
Lock接口，提供可定时的，可轮询的，可中断的锁获取操作tryLock()，可选择公平性，实现非块结构的加锁，Reentrantlock类实现了lock接口
Synchronized使用内置锁 
Wait和sleep的区别
Sleep不释放锁，必须捕获异常，属于Thread类的静态方法，只对当前对象有效
Wait释放了对象锁；只能在同步控制方法或者同步控制块中使用，否则会报“java.lang.IllegalMonitorStateException”异常，属于Object的成员方法
任务拒绝策略
同步器：信号量，倒计时门栓，障栅
Spring
Bean的生命周期
实例化，填充属性，调用setBeanName方法，调用setBeanFactory方法，调用setApplicationContext方法，调用BeanPostProcessor的beforeInitialization方法，调用自定义的初始化方法，调用BeanPostProcessor的afterInitialization方法,使用，调用disposablebean的destory方法，调用自定义销毁方法。
解决循环依赖
无法解决的：一是构造器参数循环依赖：spring容器会把每一个正在创建的bean标志符放在一个当前创建bean池中，如果在创建bean过程中发现自己已经在池中会报异常，创建完毕是将从当前创建bean池中清除。二是setter依赖注入中scope=prototype的循环依赖，spring容器不进行缓存，无法提前暴露一个创建中的bean。
Setter依赖注入中单例模式的可以解决，对于setter注入造成的依赖是通过Spring容器提前暴露刚完毕构造器注入但未完毕其它步骤（如setter注入）的Bean来完毕的
基本原理
Ioc控制反转：控制权由对象转向容器，根据配置文件创建实例并创建实例键间的依赖关系，利用java的发射机制，动态创建和调用对象。
Aop面向切面编程，动态代理。只支持方法级别的连接点。
事务如何实现，哪些配置方式
事务管理抽象主要包括3个接口
PlatformTransactionManager事务管理器（提交、回滚）
TransactionDefinition事务定义信息（隔离级别，传播行为：）
REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效
TransactionStatus事务运行状态
事务管理方式
1编程的方式，注入事务管理的模板
2声明式事务管理，xml配置，配置aop切面，或基于注解的方式@transactional,spring配置文件中开启注解事务，打开事务驱动
web.xml里面一般配了哪些东西
欢迎页面、错误页面，配置servlet，定制初始化参数，设置过滤器、监听器等，会话过期时间
加密
基本单向加密，防止信息被篡改
Base64 编码格式
MD5 信息摘要算法，
SHA 安全散列算法
HMAC 散列信息鉴别码
复杂的对称非对称加密
非对称加密：RSA
对称加密：DES

说下git有哪些指令
添加有关
git init将当前目录变为仓库
git add 文件名将文件放大暂存区
git commit –m ”描述” 将暂存区提交到仓库
查询有关
git diff 文件名 比较文件差异,暂存区和工作区 –cached比较暂存区和版本库差异 
git log 查看仓库历史记录
git reflog 查看所有版本的commit id
撤销回滚有关
git checkout – 文件名 撤销工作区的修改
git reset HEAD 文件名 撤销暂存区的修改
git reset –hard 该版本id 回退到历史版本
git reset –hard^ 回退到上个版本
图的最小路径
判断链表有环（快慢指针），链表的环的入口（一个从第一次相遇点走，一个从头走，遇到的点是环入口）
圆圈中最后剩下的数字
用两个队列实现栈

负载均衡
解释：反向代理服务器，将收到的请求按照一定的规则分发到不同服务器的过程，称为负载均衡
正向代理，客户端明确目标服务器地址，服务器不清楚来自哪个客户端
反向代理，把客户端请求代理到不同服务器，请求的来源客户端是明确的，服务器不确定

热部署，重新加载应用，生产环境
热加载，重新加载类文件，开发环境

分类：硬件负载均衡（F5负载均衡）、软件负载均衡（利用现有技术结合主机硬件实现的一种消息队列分发机制）
Nginx支持的调度算法：
1.weight轮询（默认）
2.ip_hash:解决集群部署环境下session共享的问题
3.fair:智能调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配
4.url_hash:按照访问的url的hash结果分配请求，可以在nginx作为静态服务器的情况下提高缓存效率。
数据结构
字典树
双端队列插入
循环队列
构建红黑树，avl
有序map，使用场景


算法
一致性哈希算法：分布式数据存储时，在增加和减少节点时，可以减少数据的移动。将每一个节点服务器运用hash函数计算一个hash值，分布在哈希空间上（圆环），比如以ip或主机名进行hash。对数据对象使用相同的hash函数进行hash计算，在换空间上分布在最近的节点上。
流式计算
时间戳排序，延迟队列
常用算法的时间空间复杂度
羊狼白菜过河
借书还书
取火柴
二维平面，一条线上最多的点数



**阿里**
阿里java框架
如何学java
如何看待该公司
http请求方式，post和put区别，options
out of memory，发生时处理
为什么会内存泄漏
长连接，推送
排序方式
http实现长连接

**趋势**
TCP、UDP区别
java垃圾回收
带通配符的字符串匹配
印象最深的api
推送
int Integer
进程和线程
token
进程通信，共享内存
sleep wait（锁）

**华为**
工具类
指令重排
建造者模式
状态模式
编程语言比较
项目流程
禁止复制对象
扩展性
aop
c++11
多态实现

**滴滴**
redis数据结构
跳表
时间戳排序，延迟队列
分布式锁
kafka优势
jvm
hashmap和hashtable区别
concurrenthashmap
设计模式，单例，java IO
ioc aop
变量初始化顺序
输出倒数第k个节点
锁
反向输出链表
为什么redis生成id
广度优先遍历
羊狼白菜过河
借书还书
何时建索引
数据库引擎
栈和堆
进程和线程
进程通信
索引结构
进程调度策略
负载均衡策略

**携程**
链表翻转
双端队列插入
c++与java区别
http
https
基于ssl和tsl的http协议，传输的内容经过对称加密，对称加密的秘钥使用服务器的证书进行了非对称加密
锁，崩溃未释放处理
git diff实现（最长公共后缀）
tcp怎么保证可靠
把应用数据切割成最适合发送的数据块；超时重传机制（发送数据后启动定时器，未收到确认时，重发）；对发送的每个包进行编号，按有序数据传送给应用层；保持首部和数据的校验和；流量控制（滑动窗口协议），拥塞控制；
快照判断死锁（图里有没有环）
内存分配

**美团**
实现一个hashmap
构建红黑树，avl
codecraft
hashmap是线程安全的吗
有序map，使用场景
语言相关
int数组构拼接成最小整数
设计模式
kafka（重复消费，顺序消费，观察者模式）

**网易**
kafka生产者消息丢失
cms使用场景

**腾讯**
循环队列
unique测试案例
rest架构
互联网软件（网站）架构，Resource资源网络上的实体,用uri表示；表现层是资源呈现的形式，用html,xml,json格式等表现；
状态转化（state transfer），通过客户端和服务器的交互过程，涉及数据和状态的变化，http协议中的get,post,put,delete基本操作。
redis插入性能
kafka性能
